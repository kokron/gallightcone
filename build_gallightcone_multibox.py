# Generate lightcone for DESI mocks
# from HOD catalogues generated by Shadab

#import pickle
import numpy as np
import camb
from camb import model, initialpower
import healpy as hp
import sys
#from astropy.modeling.blackbody import blackbody_nu as bb
from astropy.io import fits
import numexpr as ne

shellnum   = int(sys.argv[1]) # Shell index
shellwidth = int(sys.argv[2]) # Width of shell in Mpc/h
galtype    = int(sys.argv[3]) # type of galaxy 1=LRG,2=QSO,3=ELG 

root    = '/project2/chihway/yuuki/desi_mock/'
alist   = np.loadtxt('/project2/chihway/yuuki/desi_mock/scales.txt')

zlist   = 1/alist[:,1]-1.
origin  = [0,0,0]
boxL    = 1000
clight  = 299792458.

def tp2rd(tht,phi):
    ra  = phi/np.pi*180.0
    dec = -1*(tht/np.pi*180.0-90.0)
    return ra,dec

def checkslicehit(chilow,chihigh,xx,yy,zz):
    # doing pre-selection so that we're not loading non-intersecting blocks 
    bvx=np.array([0,boxL,boxL,   0,   0,boxL,boxL,   0])
    bvy=np.array([0,   0,boxL,boxL,   0,   0,boxL,boxL])
    bvz=np.array([0,   0,   0,   0,boxL,boxL,boxL,boxL])

    boo = 0
    r   = np.zeros(8)
    for i in range(0,8):
        sx  = (bvx[i] - origin[0] + boxL * xx);
        sy  = (bvy[i] - origin[1] + boxL * yy);
        sz  = (bvz[i] - origin[2] + boxL * zz);
        r[i]= np.sqrt(sx*sx + sy*sy + sz*sz)
    if chihigh<np.min(r):
        boo=boo+1
    if chilow>np.max(r):
        boo=boo+1
    print(chilow,chihigh,np.min(r),np.max(r))
    if (boo==0):
        return True
    else:
        return False

def getnearestsnap(alist,zmid):
    zsnap  = 1/alist[:,1]-1.
    return alist[np.argmin(np.abs(zsnap-zmid)),0]


#-------- Running camb to get comoving distances -----------

#MDPL2
#h    = 0.6777
#pars = camb.CAMBparams()
#pars.InitPower.set_params(ns=0.9611,As=np.exp(3.0663)*1e-10,pivot_scalar=0.05)# have to fiddle with this to match sigma8
#pars.set_cosmology(H0=67.77, ombh2=0.022161 ,omch2=0.11889, tau=0.0952,num_massive_neutrinos=0,mnu=0,nnu=0)
#pars.set_for_lmax(2000, lens_potential_accuracy=3)
#pars.set_matter_power(redshifts=[0.], kmax=200.0)
#pars.NonLinearModel.set_params(halofit_version='takahashi')
#camb.set_feedback_level(level=100)
#results   = camb.get_results(pars)
#print(results.get_sigma8())

#UNIT
#h    = 0.6774
#pars = camb.CAMBparams()
#pars.InitPower.set_params(ns=0.9667,As=2.142e-9,pivot_scalar=0.05)# have to fiddle with this to match sigma8
#pars.set_cosmology(H0=67.74, ombh2=0.02230 ,omch2=0.1188, tau=0.066)
pars=camb.read_ini('params_Planck15Table4LastColumn.ini')
h=pars.h
pars.set_for_lmax(2000, lens_potential_accuracy=3)
pars.set_matter_power(redshifts=[0.], kmax=200.0)
pars.NonLinearModel.set_params(halofit_version='takahashi')
camb.set_feedback_level(level=100)
results   = camb.get_results(pars)
print(results.get_sigma8())


chilow = shellwidth*(shellnum+0)
chiupp = shellwidth*(shellnum+1)
chimid = 0.5*(chilow+chiupp)
ntiles = int(np.ceil(chiupp/boxL))
print("tiling [%dx%dx%d]"%(2*ntiles,2*ntiles,2*ntiles))
zmid   = results.redshift_at_comoving_radial_distance(chimid/h)
print('Generating map for halos in the range [%3.f - %.3f Mpc/h]'%(chilow,chiupp))

nearestsnap = getnearestsnap(alist,zmid)
print('The scalefactor closest to the middle of the shell is [%.6f]'%(nearestsnap))



#--------------Loading the binary data file------------------------
d     = np.loadtxt(root+'/data/out_%dp.list.gcat'%nearestsnap)
gtype = d[:,9]
idx   = np.where(gtype==galtype)[0] #only selecting certain galaxies
ngalbox=len(idx)
px    = d[idx,0]
py    = d[idx,1]
pz    = d[idx,2]
vx    = d[idx,3]
vy    = d[idx,4]
vz    = d[idx,5]
print("using %d halos"%len(idx))
del d
#-------------------------------------------------------------------

#ntiles = 4
totra  = np.array([])
totdec = np.array([])
totz   = np.array([])
totm   = np.array([])
totdz   = np.array([])
totvlos   = np.array([])
for xx in range(-ntiles,ntiles):
    for yy in range(-ntiles,ntiles):
        for zz in range(-ntiles,ntiles):

            print("%d %d %d"%(xx,yy,zz))

            slicehit = checkslicehit(chilow,chiupp,xx,yy,zz)             # Check if box intersects with shell

            if slicehit==True:
                print('slicehit')

                for i in range(0,1):
                    sx  = ne.evaluate("px -%d + boxL * xx"%origin[0]) # dramatically faster to evaluate it this way
                    sy  = ne.evaluate("py -%d + boxL * yy"%origin[1])
                    sz  = ne.evaluate("pz -%d + boxL * zz"%origin[2])
                    r   = ne.evaluate("sqrt(sx*sx + sy*sy + sz*sz)")
                    zi  = results.redshift_at_comoving_radial_distance(r/h) # interpolated distance from position
                    idx = np.where((r>chilow) & (r<chiupp))[0]              # only select halos that are within the shell

                    if idx.size!=0:
                        ux=sx[idx]/r[idx]
                        uy=sy[idx]/r[idx]
                        uz=sz[idx]/r[idx]
                        qx=vx[idx]*1000.
                        qy=vy[idx]*1000.
                        qz=vz[idx]*1000.
                        zp=zi[idx]
                        tht,phi = hp.vec2ang(np.c_[ux,uy,uz])
                        ra,dec  = tp2rd(tht,phi)
                        vlos    = ne.evaluate("qx*ux + qy*uy + qz*uz") # dramatically faster to evaluate it this way
                        #dz      = ne.evaluate("(1+zp)/(1-vlos/clight)-1-zp")
                        dz      = ne.evaluate("(vlos/clight)*(1+zp)")
                        #vlos    = vx*sx/r + vy*sy/r + vz*sz/r #ne.evaluate("%f * %f + %f * %f + %f * %f"%(vx,sx/r,vy,sy/r,vz,sz/r)) # dramatically faster to evaluate it this way
                        #dz      = (1+zi)/1-vlos/clight-1-zi#ne.evaluate("(1+%f)/(1-%f/%f)-1-%f"%(zi,vlos,clight,zi))

                        totra   = np.append(totra,ra)
                        totdec  = np.append(totdec,dec)
                        totz    = np.append(totz,zp)
                        totdz   =  np.append(totdz,dz)
                        totvlos = np.append(totvlos,vlos/1000.) # to convert back to km/s


#np.save(root+'haloslc_%d.npy'%shellnum,np.c_[totra,totdec,totz,totm])

# Writing out the output fits file
from astropy.io import fits
import numpy as np
c1 = fits.Column(name='RA'     , array=totra    , format='E')
c2 = fits.Column(name='DEC'    , array=totdec   , format='E')
c3 = fits.Column(name='Z'      , array=totz     , format='D')
c4 = fits.Column(name='DZ'     , array=totdz    , format='E')
c5 = fits.Column(name='VEL_LOS', array=totvlos  , format='E')

hdu             = fits.BinTableHDU.from_columns([c1, c2, c3,c4,c5])
hdr             = fits.Header()
hdr['NGALBOX'] = ngalbox # total number defined as length of ra array
primary_hdu     = fits.PrimaryHDU(header=hdr)
hdul            = fits.HDUList([primary_hdu, hdu])

hdul.writeto(root+'lightcone_v3/lightcone_multibox_galtype%d_%d.fits'%(galtype,shellnum),overwrite=True)

